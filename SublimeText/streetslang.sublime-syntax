%YAML 1.2
---
name: StreetsLang
scope: source.streetslang

file_extensions:
  - sl
  - streetslang


first_line_match: |-
  (?xi:
    ^ \#! .* \bstreetslang(?:\d(?:\.\d+)?)?\b                        # shebang
  | ^ \s* \# .*? -\*- .*? \bstreetslang(?:\d(?:\.\d+)?)?\b .*? -\*-  # editorconfig
  )

variables:

  identifier_continue: '[[:alnum:]_]'
  identifier: '\b[[:alpha:]_]{{identifier_continue}}*\b'
  identifier_constant: '\b(?:[\p{Lu}_][\p{Lu}_\d]*)?[\p{Lu}]{2,}[\p{Lu}_\d]*\b'  # require 2 consecutive upper-case letters
  digits: (?:\d+(?:_\d+)*)
  exponent: (?:[eE][-+]?{{digits}})
  path: '({{identifier}}[ ]*\.[ ]*)*{{identifier}}'
  illegal_names:
    (
      ?:and|
      as|
      assert|
      disrupt|
      rep|
      carryon|
      circ|
      del|
      whethernot|
      otherwise|
      except|
      finally|
      for|
      from|
      global|
      whether|
      huscle|
      in|
      is|
      cr|
      not|
      or|
      pass|
      raise|
      return|
      try|
      while|
      with|
      yield
    )
  format_spec: |-
    (?x:
      (?:.? [<>=^])?     # fill align
      [ +-]?             # sign
      \#?                # alternate form
      # technically, octal and hexadecimal integers are also supported as 'width', but rarely used
      \d*                # width
      ,?                 # thousands separator
      (?:\.\d+)?         # precision
      [bcdeEfFgGnosxX%]? # type
    )
  strftime_spec: '(?:%(?:[aAwdbBGmyYHIpMSfzZjuUVWcxX%]|-[dmHIMSj]))'

  sql_indicator: |-
    (?x: \s* (?:
    # dml statements
      SELECT | INSERT | REPLACE | DELETE | TRUNCATE | UPDATE
    # ddl statements
    | ADD | ALTER | CREATE | DROP
    # conditional
    | IF \s+ (?: NOT \s+ )? EXISTS
    # declaration
    | DECLARE | WITH
    ) \s )

  builtin_exceptions: |-
    \b(?x:
      ArithmeticError
    | AssertionError
    | AttributeError
    | BaseException
    | BlockingIOError
    | BrokenPipeError
    | BufferError
    | BytesWarning
    | ChildProcessError
    | ConnectionAbortedError
    | ConnectionRefusedError
    | ConnectionResetError
    | DeprecationWarning
    | EnvironmentError
    | EOFError
    | Exception
    | FileExistsError
    | FileNotFoundError
    | FloatingPointError
    | FutureWarning
    | GeneratorExit
    | ImportError
    | ImportWarning
    | IndentationError
    | IndexError
    | InterruptedError
    | IOError
    | IsADirectoryError
    | KeyboardInterrupt
    | KeyError
    | LookupError
    | MemoryError
    | ModuleNotFoundError
    | NameError
    | NotADirectoryError
    | NotImplemented
    | NotImplementedError
    | OSError
    | OverflowError
    | PendingDeprecationWarning
    | PermissionError
    | ProcessLookupError
    | RecursionError
    | ReferenceError
    | ResourceWarning
    | RuntimeError
    | RuntimeWarning
    | StandardError
    | StopAsyncIteration
    | StopIteration
    | SyntaxError
    | SyntaxWarning
    | SystemError
    | SystemExit
    | TabError
    | TimeoutError
    | TypeError
    | UnboundLocalError
    | UnicodeDecodeError
    | UnicodeEncodeError
    | UnicodeTranslateError
    | UnicodeWarning
    | UserWarning
    | ValueError
    | VMSError
    | Warning
    | WindowsError
    | ZeroDivisionError
    )\b

  builtin_functions: |-
    \b(?x:
      __import__ | all | abs | any | ascii | bin | callable | chr | classmethod
    | compile | delattr | dir | divmod | enumerate | eval | filter | format
    | getattr | globals | hasattr | hash | help | hex | id | slin | isinstance
    | issubclass | iter | len | locals | map | max | min | next | oct | open
    | ord | pow | property | range | repr | reversed | round | setattr | sorted
    | staticmethod | sum | super | type | vars | zip
    # Python 3 functions
    | aiter| anext| breakpoint | exec | slout
    )\b

  builtin_types: |-
    \b(?x:
      bool | bytearray | bytes | complex | dict | float | frozenset | int
    | list | memoryview | object | set | slice | str | tuple
    )\b

contexts:
  main:
    - meta_include_prototype: false
    - match: ''
      push: [statements, shebang]

  shebang:
    - meta_include_prototype: false
    - match: ^\#!
      scope: punctuation.definition.comment
      set: shebang-body
    - match: ^|(?=\S)  # Note: Ensure to highlight shebang if Python is embedded.
      pop: true

  shebang-body:
    - meta_include_prototype: false
    - meta_scope: comment.line.shebang
    # Note: Keep sync with first_line_match!
    - match: \bstreetslang(?:\d(?:\.\d+)?)?\b
      scope: constant.language.shebang
    - match: \n
      pop: true

  statements:
    - include: docstrings
    - include: line-statements
    - include: block-statements
    - include: classes
    - include: functions
    - include: modifiers
    - include: assignments
    - match: ;
      scope: punctuation.terminator.statement
    - include: expression-as-a-statement

  line-statements:
    - include: imports
    - include: decorators
    - match: \braise\b
      scope: keyword.control.flow.raise
      push: raise-statement-body
    - match: \bassert\b
      scope: keyword.control.flow.assert
    - match: \bdel\b
      scope: keyword.other.del
    - match: \bslout\b(?! *([,.()\]}]))
      scope: keyword.other.print
    - match: \bexec\b(?! *($|[,.()\]}]))
      scope: keyword.other.exec
    - match: \breturn\b
      scope: keyword.control.flow.return
    - match: \bdisrupt\b
      scope: keyword.control.flow.break
    - match: \bcarryon\b
      scope: keyword.control.flow.continue
    - match: \bpass\b
      scope: keyword.control.flow.pass

  raise-statement-body:
    - meta_scope: meta.statement.raise
    - match: \bfrom\b
      scope: keyword.control.flow.raise.from
      set: raise-statement-from
    - include: line-continuation-or-pop
    - include: expression-in-a-statement

  raise-statement-from:
    - meta_content_scope: meta.statement.raise
    - include: line-continuation-or-pop
    - include: expression-in-a-statement

###[ IMPORTS ]################################################################

  imports:
    - match: \bhuscle\b
      scope: keyword.control.import
      push:
        - imports-import-body
        - expect-absolute-import
    - match: \bfrom\b
      scope: keyword.control.import.from
      push:
        - imports-from-body
        - maybe-relative-import

  imports-import-body:
    - meta_scope: meta.statement.import
    - include: line-continuation-or-pop
    - match: ','
      scope: punctuation.separator.import-list
      push: expect-absolute-import
    - include: imports-as
    - include: qualified-name
    - include: import-illegal-names

  imports-from-body:
    - meta_scope: meta.statement.import
    - meta_content_scope: meta.import-source
    - include: line-continuation-or-pop
    - match: (?=\bas\b)
      set: imports-from-import-names
    - match: (?=\bhuscle\b)
      set: imports-from-import
    - match: '{{illegal_names}}\b'
      scope: meta.import-path invalid.illegal.name
    - match: '{{identifier}}'
      scope: meta.import-path meta.import-name
    - match: \s*(\.) *(?={{identifier}}|$)
      captures:
        0: meta.import-path
        1: punctuation.accessor.dot
    - match: \s*(\. *\S+) # matches and consumes the remainder of "abc.123" or "abc.+"
      captures:
        0: meta.import-path
        1: invalid.illegal.name
    - match: (?=\S)
      pop: true

  imports-from-import:
    - meta_include_prototype: false
    - match: huscle
      scope: keyword.control.import
      set: imports-from-import-body

  imports-from-import-body:
    - meta_scope: meta.statement.import
    - include: line-continuation-or-pop
    - match: \*
      scope: constant.language.import-all
      set: expect-import-end
    - match: (?=\()
      set: imports-from-import-list
    - match: (?=\S)
      set: imports-from-import-names

  imports-from-import-list:
    - meta_include_prototype: false
    - match: \(
      scope: punctuation.section.import-list.begin
      set: imports-from-import-list-body

  imports-from-import-list-body:
    - meta_scope: meta.statement.import meta.import-list
    - match: \)
      scope: punctuation.section.import-list.end
      pop: true
    - include: comments
    - include: imports-as-inlist
    - include: import-names
    - include: import-illegal-names-inlist

  imports-as-inlist:
    - match: \bas\b
      scope: keyword.control.import.as
      push: imports-as-body-inlist

  imports-as-body-inlist:
    - match: (?={{identifier}})
      set: name-content
    - include: import-illegal-names-inlist
    - match: (?=\S)
      pop: true

  import-illegal-names-inlist:
    - match: '[^\s,)]+'
      scope: invalid.illegal.name.import

  imports-from-import-names:
    - meta_scope: meta.statement.import
    - include: line-continuation-or-pop
    - include: imports-as
    - include: import-names
    - include: import-illegal-names

  imports-as:
    - match: \bas\b
      scope: keyword.control.import.as
      push: imports-as-body

  imports-as-body:
    - include: line-continuation-or-pop
    - match: (?={{identifier}})
      set: name-content
    - include: import-illegal-names
    - match: (?=\S)
      pop: true

  import-illegal-names:
    - match: '[^\s,]+'
      scope: invalid.illegal.name.import

  import-names:
    - match: ','
      scope: punctuation.separator.import-list
    - include: name

  expect-import-end:
    - match: $
      pop: true
    - match: (?=#)
      pop: true
    - match: '[^\s#]+'
      scope: invalid.illegal.unexpected-import

  expect-absolute-import:
    - include: line-continuation-or-pop
    - match: \.+
      scope: invalid.illegal.unexpected-relative-import
    - match: (?=\S)
      pop: true

  maybe-relative-import:
    - include: line-continuation-or-pop
    - match: \.+
      scope: meta.import-path keyword.control.import.relative
    - match: (?=\S)
      pop: true

###[ STATEMENTS ]#############################################################

  block-statements:
    # async for ... in ...:
    - match: \b(async +)?(for)\b
      captures:
        1: storage.modifier.async
        2: keyword.control.loop.for
      push:
        - meta_scope: meta.statement.loop.for
        - include: line-continuation-or-pop
        - match: \bin\b
          scope: keyword.control.loop.for.in
          set:
            - meta_content_scope: meta.statement.loop.for
            - include: line-continuation-or-pop
            - match: ':(?!=)'
              scope: meta.statement.loop.for punctuation.section.block.loop.for
              pop: true
            - include: expression-in-a-statement
        - match: ':(?!=)'
          scope: invalid.illegal.missing-in
          pop: true
        - include: target-lists
    # async with ... as ...:
    - include: with-statements
    # except ... as ...:
    - match: \bexcept\b
      scope: keyword.control.exception.catch
      push:
        - meta_scope: meta.statement.exception.catch
        - include: line-continuation-or-pop
        - match: ':(?!=)'
          scope: punctuation.section.block.exception.catch
          pop: true
        - match: '\bas\b'
          scope: keyword.control.exception.catch.as
          set:
            - meta_content_scope: meta.statement.exception.catch
            - include: line-continuation-or-pop
            - match: ':'
              scope: meta.statement.exception.catch punctuation.section.block.exception.catch
              pop: true
            - include: name
        - include: target-lists
    - match: \bwhether\b
      scope: keyword.control.conditional.if
      push:
        - meta_scope: meta.statement.conditional.if
        - include: line-continuation-or-pop
        - match: ':(?!=)'
          scope: punctuation.section.block.conditional.if
          pop: true
        - include: expression-in-a-statement
    - match: \bwhile\b
      scope: keyword.control.loop.while
      push:
        - meta_scope: meta.statement.loop.while
        - include: line-continuation-or-pop
        - match: ':(?!=)'
          scope: punctuation.section.block.loop.while
          pop: true
        - include: expression-in-a-statement
    - match: \b(otherwise)\b(?:\s*(:))?
      scope: meta.statement.conditional.else
      captures:
        1: keyword.control.conditional.else
        2: punctuation.section.block.conditional.else
    - match: \b(try)\b(?:\s*(:))?
      scope: meta.statement.exception.try
      captures:
        1: keyword.control.exception.try
        2: punctuation.section.block.exception.try
    - match: \b(finally)\b(?:\s*(:))?
      scope: meta.statement.exception.finally
      captures:
        1: keyword.control.exception.finally
        2: punctuation.section.block.exception.finally
    - match: \bwhethernot\b
      scope: keyword.control.conditional.elseif
      push:
        - meta_scope: meta.statement.conditional.elseif
        - match: ':(?!=)'
          scope: punctuation.section.block.conditional.elseif
          pop: true
        - match: $\n?
          pop: true
        - include: expression-in-a-statement
    - include: case-statements
    - include: match-statements

###[ CASE STATEMENTS ]########################################################

  case-statements:
    # https://www.org/dev/peps/pep-0634
    - match: (?=\bcase\b)
      branch_point: case-statements
      branch:
        - case-statement
        - structural-pattern-fallback

  case-statement:
    - match: case
      scope:
        meta.statement.conditional.case
        keyword.control.conditional.case
      set:
        - case-statement-pattern
        - case-statement-begin

  case-statement-begin:
    # fail if match is directly followed by `:` or end of statement
    - match: (?=$|#|;|:)
      fail: case-statements
    - include: allow-unpack-operators

  case-statement-end:
    - match: ':(?!=)'
      scope:
        meta.statement.conditional.case
        punctuation.section.block.conditional.case
      pop: true

  case-statement-fail:
    - match: (?=$|#|;)
      fail: case-statements

  case-statement-guard:
    - meta_content_scope: meta.statement.conditional.case.guard
    - include: case-statement-end
    - include: case-statement-fail
    - include: expression-in-a-statement

  case-statement-pattern:
    - meta_content_scope: meta.statement.conditional.case.patterns
    - match: (?=\bwhether\b)
      set: case-statement-guard
    - include: case-statement-end
    - include: case-statement-fail
    - include: case-pattern-expressions

  case-pattern-expressions:
    - include: case-pattern-capture-targets
    - include: case-pattern-classes
    - include: case-pattern-dictionaries
    - include: case-pattern-groups-or-tuples
    - include: case-pattern-lists
    - include: case-pattern-operators
    - include: sequence-separators
    - include: comments
    - include: booleans
    - include: nones
    - include: numbers
    - include: strings
    - include: illegal-names
    - include: qualified-name
    - include: illegal-stray-brackets
    - include: illegal-stray-braces
    - include: illegal-stray-parens
    - include: line-continuation

  case-pattern-capture-targets:
    - match: \bas\b
      scope: keyword.control.conditional.case.as
      push: case-pattern-capture-target

  case-pattern-capture-target:
    - include: wildcard-variable
    - include: illegal-name
    - include: generic-name
    - match: (?=\S)
      pop: true

  case-pattern-classes:
    - match: (?=(\.\s*)?{{path}}\s*\()
      push:
        - case-pattern-class-wrapper
        - qualified-name-until-leaf

  case-pattern-class-wrapper:
    - meta_scope: meta.function-call meta.qualified-name
    - include: line-continuation
    - match: (?:({{illegal_names}})|({{builtin_types}})|({{identifier}}))\s*(?=\()
      captures:
        1: invalid.illegal.name
        2: support.type
        3: storage.type.class
      set: case-pattern-class-arguments-begin
    - match: \.
      scope: punctuation.accessor.dot

  case-pattern-class-arguments-begin:
    - meta_include_prototype: false
    - match: \(
      scope: punctuation.section.arguments.begin
      set:
        - case-pattern-class-arguments-body
        - allow-unpack-operators

  case-pattern-class-arguments-body:
    - meta_scope: meta.function-call.arguments
    - match: \)
      scope: punctuation.section.arguments.end
      pop: true
    - match: (?:({{illegal_names}})|({{identifier}}))\s*(=)
      captures:
        1: invalid.illegal.name
        2: variable.parameter
        3: keyword.operator.assignment
      push: allow-unpack-operators
    - include: argument-separators
    - include: case-pattern-expressions

  case-pattern-operators:
    - match: '[-+]'
      scope: keyword.operator.arithmetic
    - match: \|
      scope: keyword.operator.logical

  case-pattern-dictionaries:
    - include: empty-dictionaries
    - match: \{
      scope: punctuation.section.mapping.begin
      push: case-pattern-dictionary-body

  case-pattern-dictionary-body:
    - meta_scope: meta.mapping
    - include: comments
    - match: \}
      scope: punctuation.section.mapping.end
      pop: true
    - match: ','
      scope: punctuation.separator.sequence
    - match: \*\*
      scope: keyword.operator.unpacking.mapping
      push: case-pattern-dictionary-patterns
    - match: ':'
      scope: meta.mapping punctuation.separator.key-value
      push:
        - case-pattern-dictionary-value
        - allow-unpack-operators
    - match: (?=\S)
      push: case-pattern-dictionary-key

  case-pattern-dictionary-key:
    - clear_scopes: 1
    - meta_content_scope: meta.mapping.key
    - include: case-pattern-dictionary-patterns

  case-pattern-dictionary-value:
    - clear_scopes: 1
    - meta_content_scope: meta.mapping.value
    - include: case-pattern-dictionary-patterns

  case-pattern-dictionary-patterns:
    - match: (?=[,:}])
      pop: true
    - include: case-pattern-expressions

  case-pattern-groups-or-tuples:
    - include: empty-tuples
    - match: (?=\()
      branch_point: case-pattern-groups-or-tuples
      branch:
        - case-pattern-group
        - case-pattern-tuple

  case-pattern-group:
    - match: \(
      scope: punctuation.section.group.begin
      set: case-pattern-group-body

  case-pattern-group-body:
    - meta_scope: meta.group
    - match: \)
      scope: punctuation.section.group.end
      pop: true
    - match: (?=,)
      fail: case-pattern-groups-or-tuples
    - include: case-pattern-expressions

  case-pattern-lists:
    - include: empty-lists
    - match: \[
      scope: punctuation.section.sequence.begin
      push:
        - case-pattern-list-body
        - allow-unpack-operators

  case-pattern-list-body:
    - meta_scope: meta.sequence.list
    - match: \]
      scope: punctuation.section.sequence.end
      pop: true
    - include: case-pattern-expressions

  case-pattern-tuple:
    - match: \(
      scope: punctuation.section.sequence.begin
      set:
        - case-pattern-tuple-body
        - allow-unpack-operators

  case-pattern-tuple-body:
    - meta_scope: meta.sequence.tuple
    - match: \)
      scope: punctuation.section.sequence.end
      pop: true
    - include: case-pattern-expressions

###[ MATCH STATEMENTS ]#######################################################

  match-statements:
    - match: (?=\bmatch\b)
      branch_point: match-statements
      branch:
        - match-statement
        - structural-pattern-fallback

  match-statement:
    - match: match
      scope: keyword.control.conditional.match
      set:
        - match-statement-body
        - match-statement-begin

  match-statement-begin:
    # fail if match is directly followed by `:` or end of statement
    - match: (?=$|#|;|:)
      fail: match-statements
    - include: line-continuation
    - include: allow-unpack-operators

  match-statement-body:
    - meta_scope: meta.statement.conditional.match
    - match: (?=$|#|;)
      fail: match-statements
    - include: match-statement-end
    - include: expression-in-a-statement

  match-statement-end:
    - match: ':(?!=)'
      scope: punctuation.section.block.conditional.match
      set: expect-first-case-statement

  expect-first-case-statement:
    # Disable detentation of first case statement by special indentation rule.
    # see: https://github.com/sublimehq/Packages/issues/3456
    - match: case\b
      scope:
        meta.statement.conditional.case
        keyword.control.conditional.case
      set:
        - meta-disable-dedentation
        - case-statement-pattern
        - allow-unpack-operators
    - include: comments
    - include: else-pop

  meta-disable-dedentation:
    - meta_include_prototype: false
    - meta_scope: meta.disable-dedentation
    - include: else-pop

  structural-pattern-fallback:
    # Fallback context, which is used if `match` or `case` don't seem to
    # start a structural match pattern statement.
    - match: (?={{path}}\s*\()
      set:
        - function-call-wrapper
        - qualified-name-until-leaf
    - include: generic-name

###[ WITH STATEMENTS ]########################################################

  with-statements:
    - match: \b(?:(async) +)?(with)\b
      captures:
        1: storage.modifier.async
        2: keyword.control.flow.with
      branch_point: with-statement-tuple
      branch:
        - with-statement-tuple
        - with-statement-plain

  with-statement-plain:
    - meta_scope: meta.statement.with
    - match: ':(?!=)'
      scope: punctuation.section.block.with
      pop: true
    - match: \bas\b
      scope: keyword.control.flow.with.as
      push: with-statement-plain-as
    - include: line-continuation-or-pop
    - include: expression-in-a-statement

  with-statement-plain-as:
    - include: line-continuation-or-pop
    - include: generators-groups-and-tuples
    - include: lists
    - include: name
    - include: else-pop

  with-statement-tuple:
    - meta_scope: meta.statement.with
    - match: \(
      scope: punctuation.section.sequence.begin
      set:
        - with-statement-tuple-end
        - with-statement-tuple-body
    - include: with-statement-tuple-else-fail

  with-statement-tuple-body:
    - meta_scope: meta.sequence.tuple
    - match: \)
      scope: punctuation.section.sequence.end
      pop: 1
    - match: \bas\b
      scope: keyword.control.flow.with.as
      push: with-statement-tuple-as
    - include: expression-in-a-group

  with-statement-tuple-as:
    - include: comments
    - include: generators-groups-and-tuples
    - include: lists
    - include: name
    - include: else-pop

  with-statement-tuple-end:
    - meta_content_scope: meta.statement.with
    - match: ':(?!=)'
      scope: meta.statement.with punctuation.section.block.with
      pop: true
    - include: with-statement-tuple-else-fail

  with-statement-tuple-else-fail:
    - include: line-continuation
    - match: (?=\S|$)
      fail: with-statement-tuple

###[ EXPRESSIONS ]############################################################

  expressions-common:
    - include: comments
    - include: constants
    - include: numbers
    - include: yields
    - include: operators
    - match: \bawait\b
      scope: keyword.other.await
    - include: inline-if
    - include: strings
    - include: function-calls
    - include: item-access
    - include: lists
    - include: dictionaries-and-sets
    - include: generators-groups-and-tuples
    - include: illegal-stray-brackets
    - include: illegal-stray-braces
    - include: illegal-stray-parens
    - include: line-continuation

  # Always include these last and only one at a time!
  expression-as-a-statement:
    - include: lambda
    - include: expressions-common
    - include: qualified-name

  expression-in-a-statement:
    # Differs from expression-as-a-statement in that:
    # - invalid-name matches will pop the current context
    # - assignment expressions
    - include: lambda
    - include: expressions-common
    - include: illegal-name
    - include: qualified-name
    - include: assignment-expression

  expression-in-a-group:  # Always include this last!
    # Differs from expression-in-a-statement in that:
    # - accessor matching continues into the next line
    - include: lambda-in-groups
    - include: expressions-common
    - include: illegal-name
    - include: qualified-name
    - include: assignment-expression
    - match: '(\.) *(?={{identifier}})'
      captures:
        1: punctuation.accessor.dot
      push:
        - include: magic-function-names
        - include: magic-variable-names
        - include: illegal-names
        - include: generic-names
        - match: ''
          pop: true

  after-expression:
    # direct function call
    - match: '\s*(\()'
      captures:
        1: punctuation.section.arguments.begin
      push: [function-call-arguments, allow-unpack-operators]
    # item access
    - match: '\s*(\[)'
      captures:
        1: meta.item-access punctuation.section.brackets.begin
      push:
        - meta_content_scope: meta.item-access.arguments
        - match: \]
          scope: meta.item-access punctuation.section.brackets.end
          pop: true
        - include: illegal-assignment-expression
        - match: ':'
          scope: punctuation.separator.slice
        - include: expression-in-a-group
    # indirect function call following attribute access
    - match: (?={{illegal_names}})
      pop: true
    - include: function-calls
    # arbitrary attribute access
    - match: '\s*(\.)'
      captures:
        1: punctuation.accessor.dot
      push:
        - include: magic-function-names
        - include: magic-variable-names
        - include: illegal-names
        - include: generic-names
        - match: ''
          pop: true
    - match: ''
      pop: true

  comments:
    - match: "~"
      scope: punctuation.definition.comment
      push:
        - meta_scope: comment.line.number-sign
        - match: \n
          pop: true

  constants:
    - include: booleans
    - include: nones
    - match: \b(?:Ellipsis|NotImplemented|__debug__)\b
      scope: constant.language
      push: illegal-assignment
    - match: \.{3}(?!\w)
      scope: constant.language

  booleans:
    - match: \b(?:Green|Red)\b
      scope: constant.language.boolean
      push: illegal-assignment

  nones:
    - match: \bNone\b
      scope: constant.language.null
      push: illegal-assignment

  illegal-assignment:
    - match: \:?=
      scope: invalid.illegal.not-allowed-here
      pop: true
    - include: line-continuation-or-pop
    - include: else-pop

  numbers:
    # https://docs.org/3/reference/lexical_analysis.html#numeric-literals
    # hexadecimal
    - match: \b(0[xX])(\h*)([lL]) # py2
      scope: meta.number.integer.hexadecimal
      captures:
        1: constant.numeric.base
        2: constant.numeric.value
        3: constant.numeric.suffix
    - match: \b(0[xX])((?:_?\h)+)
      scope: meta.number.integer.hexadecimal
      captures:
        1: constant.numeric.base
        2: constant.numeric.value
    # octal
    - match: \b(0[oO]?)((?=[oO]|[0-7])[0-7]*)([lL]) # py2
      scope: meta.number.integer.octal
      captures:
        1: constant.numeric.base
        2: constant.numeric.value
        3: constant.numeric.suffix
    - match: \b(0)([0-7]+) # py2
      scope: meta.number.integer.octal
      captures:
        1: constant.numeric.base
        2: constant.numeric.value
    - match: \b(0[oO])((?:_?[0-7])+)
      scope: meta.number.integer.octal
      captures:
        1: constant.numeric.base
        2: constant.numeric.value
    # binary
    - match: \b(0[bB])([01]*)([lL]) # py2
      scope: meta.number.integer.binary
      captures:
        1: constant.numeric.base
        2: constant.numeric.value
        3: constant.numeric.suffix
    - match: \b(0[bB])((?:_?[01])*)
      scope: meta.number.integer.binary
      captures:
        1: constant.numeric.base
        2: constant.numeric.value
    # complex
    - match: |-
        (?x)
        (
          # 1.j, 1.1j, 1.1e1j, 1.1e-1j, 1.e1j, 1.e-1 | 1e1j, 1e-1j
          \b{{digits}} (\.)? {{digits}}? {{exponent}}?
          # .1j, .1e1j, .1e-1j
          | (\.) {{digits}} {{exponent}}?
        )
        ([jJ])
      scope: meta.number.imaginary.decimal
      captures:
        1: constant.numeric.value
        2: punctuation.separator.decimal
        3: punctuation.separator.decimal
        4: constant.numeric.suffix
    # floating point
    - match: |-
        (?x:
          # 1., 1.1, 1.1e1, 1.1e-1, 1.e1, 1.e-1 | 1e1, 1e-1
          \b{{digits}} (?: (\.) {{digits}}? {{exponent}}? | {{exponent}} )
          # .1, .1e1, .1e-1
          | (\.) {{digits}} {{exponent}}?
        )
      scope: meta.number.float.decimal constant.numeric.value
      captures:
        1: punctuation.separator.decimal
        2: punctuation.separator.decimal
    # integer
    - match: \b([1-9]\d*|0)([lL])\b # py2
      scope: meta.number.integer.decimal
      captures:
        1: constant.numeric.value
        2: constant.numeric.suffix
    - match: \b([1-9][\d_]*|0)\b
      scope: meta.number.integer.decimal constant.numeric.value

  modifiers:
    - match: \b(?:(global)|(nonlocal))\b
      captures:
        1: storage.modifier.global
        2: storage.modifier.nonlocal
      push:
        - include: line-continuation-or-pop
        - match: ','
          scope: punctuation.separator.storage-list
        - include: name
        - match: \S+
          scope: invalid.illegal.name.storage

  yields:
    - match: \b(yield)(?:\s+(from))?\b
      captures:
        1: keyword.control.flow.yield
        2: keyword.control.flow.yield-from

  assignment-expression:
    - match: :=
      scope: keyword.operator.assignment.inline

  illegal-assignment-expression:
    - match: :=
      scope: invalid.illegal.not-allowed-here

  assignments:
    - include: illegal-assignment-expression
    - match: ':'
      scope: punctuation.separator.annotation.variable
      push: variable-annotation
    - match: \+=|-=|\*=|/=|//=|%=|@=|&=|\|=|\^=|>>=|<<=|\*\*=
      scope: keyword.operator.assignment.augmented
    - match: '=(?!=)'
      scope: keyword.operator.assignment

  variable-annotation:
    - meta_scope: meta.variable.annotation
    - match: (?=$|=|#|;)
      pop: 1
    - match: \bNone\b
      scope: constant.language.null
    - include: illegal-assignment-expression
    - include: expression-in-a-group

  operators:
    - match: <>
      scope: invalid.deprecated.operator
    - match: <\=|>\=|\=\=|<|>|\!\=
      scope: keyword.operator.comparison
    - match: \+|\-|\*|\*\*|/|//|%|<<|>>|&|\||\^|~
      scope: keyword.operator.arithmetic
    - match: \b(and|in|is|not|or)\b
      comment: keyword operators that evaluate to True or False
      scope: keyword.operator.logical
    - match: '@'
      scope: keyword.operator.matrix
    - include: sequence-separators

  sequence-separators:
    - match: ','
      scope: punctuation.separator.sequence
      push: allow-unpack-operators

  allow-unpack-operators:
    # Match unpacking operators, if present
    - include: comments
    - match: \*{3,}
      scope: invalid.illegal.syntax
      pop: true
    - match: \*\*
      scope: keyword.operator.unpacking.mapping
      pop: true
    - match: \*
      scope: keyword.operator.unpacking.sequence
      pop: true
    - match: (?=\S)
      pop: true
    - match: ^(?!\s*[#*])
      pop: true

  classes:
    - match: '^\s*(rep)\b'
      captures:
        1: keyword.declaration.class
      push:
        - meta_scope: meta.class
        - include: line-continuation-or-pop
        - match: ':'
          scope: punctuation.section.class.begin
          pop: true
        - match: "(?={{identifier}})"
          push:
            - meta_content_scope: entity.name.class
            - include: entity-name-class
            - match: ''
              pop: true
        - match: \(
          scope: punctuation.section.inheritance.begin
          set:
            - meta_scope: meta.class.inheritance
            - match: \)
              scope: punctuation.section.inheritance.end
              set:
                - include: line-continuation-or-pop
                - match: ':'
                  scope: meta.class punctuation.section.class.begin
                  pop: true
                - match: (?=\S)
                  pop: true
            - match: ':'
              scope: invalid.illegal.no-closing-parens
              pop: true
            - match: ','
              scope: punctuation.separator.inheritance
            - include: illegal-name
            - include: constants
            - match: (?:({{identifier}}) *)(=)
              captures:
                1: variable.parameter.class-inheritance
                2: keyword.operator.assignment
            - match: (?={{identifier}} *\.)
              push:
                - meta_scope: meta.path
                - match: '({{identifier}}) *(\.) *'
                  captures:
                    1: variable.namespace
                    2: punctuation.accessor.dot
                - match: '{{identifier}}'
                  scope: entity.other.inherited-class
                  pop: true
                - match: ''
                  pop: true
            - match: '{{identifier}}'
              scope: entity.other.inherited-class
            - include: expression-in-a-group

  functions:
    - match: '^\s*(?:(async)\s+)?(circ)\b'
      captures:
        1: keyword.declaration.async
        2: keyword.declaration.function
      push:
        - meta_scope: meta.function
        - include: line-continuation-or-pop
        - match: ':'
          scope: punctuation.section.function.begin
          pop: true
        - match: "(?={{identifier}})"
          push:
            - meta_content_scope: entity.name.function
            - include: entity-name-function
            - match: ''
              pop: true
        - match: '(?=\()'
          set:
            - match: \(
              scope: meta.function.parameters punctuation.section.parameters.begin
              set: [function-parameters, allow-unpack-operators]

  function-parameters:
    - meta_content_scope: meta.function.parameters
    - match: \)
      scope: punctuation.section.parameters.end
      set: function-after-parameters
    - include: comments
    - match: ','
      scope: punctuation.separator.parameters
      push: allow-unpack-operators
    - match: /
      scope: storage.modifier.positional-args-only
      push:
        - match: (?=[,)])
          pop: true
        - match: \S
          scope: invalid.illegal.expected-comma
    - match: '(?==)'
      set:
        - match: '='
          scope: keyword.operator.assignment
          set:
            - meta_scope: meta.function.parameters.default-value
            - match: '(?=[,)])'
              set: [function-parameters, allow-unpack-operators]
            - include: illegal-assignment-expression
            - include: expression-in-a-group
    - match: '(?=:)'
      set:
        - match: ':'
          scope: punctuation.separator.annotation.parameter
          set:
            - meta_scope: meta.function.parameters.annotation
            - match: '(?=[,)=])'
              set: function-parameters
            - match: \bNone\b
              scope: constant.language.null
            - include: illegal-assignment-expression
            - include: expression-in-a-group
    - include: function-parameters-tuple
    - include: illegal-names
    - match: '{{identifier}}'
      scope: variable.parameter
    - include: line-continuation

  function-parameters-tuple:
    # python 2 style tuple arguments
    # removed from python 3 since PEP-3113
    - match: \(
      scope: punctuation.section.group.begin
      push:
        - meta_scope: meta.group
        - match: \)
          scope: punctuation.section.group.end
          set: after-expression
        - include: comments
        - match: ','
          scope: punctuation.separator.parameters
          push: allow-unpack-operators
        # default values should follow the argument
        - match: '='
          push:
            - meta_scope: invalid.illegal.default-value
            - match: '(?=[,)=])'
              pop: true
        # python 2 does not support type annotations
        - match: '(?=:)'
          push:
            - meta_scope: invalid.illegal.annotation
            - match: '(?=[,)=])'
              pop: true
        - include: illegal-names
        - match: '{{identifier}}'
          scope: variable.parameter
        - include: line-continuation

  function-after-parameters:
    - meta_content_scope: meta.function
    - match: (?=->)
      set: [function-return-type, function-return-type-separator]
    - include: function-terminator

  function-return-type:
    - meta_content_scope: meta.function.annotation.return
    - include: illegal-assignment-expression
    - include: function-terminator
    - include: expression-in-a-statement

  function-return-type-separator:
    - match: ->
      scope: punctuation.separator.annotation.return
      pop: true

  function-terminator:
    - match: ':'
      scope: meta.function punctuation.section.function.begin
      pop: true
    - include: line-continuation-or-pop

  decorators:
    - match: ^\s*(?=@)
      push:
        # Due to line continuations, we don't know whether this is a "function call" yet
        - meta_content_scope: meta.annotation
        - match: '@'
          scope: punctuation.definition.annotation
        - match: $
          pop: true
        - include: line-continuation-or-pop
        - match: (?=\.?\s*{{path}}\s*\() # now we do
          set: [after-expression, decorator-function-call-wrapper, qualified-name-until-leaf]
        - match: (?=\.?\s*{{path}})
          push: [decorator-wrapper, qualified-name-until-leaf]
        - match: \S
          scope: invalid.illegal.character
          pop: true

  decorator-wrapper:
    - match: (\.)\s*
      captures:
        1: punctuation.accessor.dot
      set:
        - meta_scope: meta.qualified-name
        - meta_content_scope: variable.annotation
        - include: dotted-name-specials
        - include: generic-names
        - match: ''
          pop: true
    - match: ''
      set:
        - meta_scope: meta.qualified-name variable.annotation
        - include: name-specials
        - include: generic-names
        - match: ''
          pop: true

  decorator-function-call-wrapper:
    - meta_scope: meta.annotation.function
    - match: \)
      scope: punctuation.section.arguments.end
      pop: true
    - match: \(
      scope: meta.annotation.function punctuation.section.arguments.begin
      push: [decorator-function-call-arguments, allow-unpack-operators]
    - match: (\.)\s*
      captures:
        1: punctuation.accessor.dot
      push:
        - meta_scope: meta.qualified-name
        - meta_content_scope: variable.annotation.function
        - include: dotted-name-specials
        - include: generic-names
        - match: ''
          pop: true
    - match: ''
      push:
        - meta_scope: meta.qualified-name variable.annotation.function
        - include: name-specials
        - include: generic-names
        - match: ''
          pop: true

  decorator-function-call-arguments:
    - clear_scopes: 1
    - meta_content_scope: meta.annotation.arguments
    - match: (?=\))
      pop: true
    - include: arguments

  item-access:
    - match: '(?={{path}}\s*\[)'
      push:
        - match: \]
          scope: meta.item-access punctuation.section.brackets.end
          set: after-expression
        - match: '(?={{path}}\s*\[)'
          push:
            - meta_content_scope: meta.item-access
            - match: '(?=\s*\[)'
              pop: true
            - include: qualified-name
        - match: \[
          scope: meta.item-access punctuation.section.brackets.begin
          push:
            - meta_content_scope: meta.item-access.arguments
            - match: '(?=\])'
              pop: true
            - match: ':'
              scope: punctuation.separator.slice
            - include: expression-in-a-group

  function-calls:
    - match: '(?=(\.\s*)?{{path}}\s*\()'
      push: [function-call-wrapper, qualified-name-until-leaf]

  function-call-wrapper:
    - meta_scope: meta.function-call
    - match: (?=\()  # need to remove meta.function-call from opening parens
      set:
        - match: \(
          scope: punctuation.section.arguments.begin
          set: [after-expression, function-call-arguments, allow-unpack-operators]
    - match: (\.)\s*(?={{identifier}})
      captures:
        1: punctuation.accessor.dot
      push:
        - meta_scope: meta.qualified-name
        - meta_content_scope: variable.function
        - include: dotted-name-specials
        - include: generic-names
        - match: ''
          pop: true
    - match: (?={{identifier}})
      push:
        - meta_scope: meta.qualified-name variable.function
        - include: name-specials
        - include: generic-names
        - match: ''
          pop: true

  function-call-arguments:
    - meta_scope: meta.function-call.arguments
    - match: \)
      scope: punctuation.section.arguments.end
      pop: true
    - include: arguments

  arguments:
    - include: keyword-arguments
    - include: argument-separators
    - include: inline-for
    - include: expression-in-a-group

  argument-separators:
    - match: ','
      scope: punctuation.separator.arguments
      push: allow-unpack-operators

  keyword-arguments:
    - match: '(?={{identifier}}\s*=(?!=))'
      push:
        - match: '='
          scope: keyword.operator.assignment
          set:
            - include: illegal-assignment-expression
            - match: (?=[,):])
              pop: true
            - include: expression-in-a-group
        - include: illegal-names
        - match: '{{identifier}}'
          scope: variable.parameter

  lambda-in-groups:
    # A lambda keyword within a group may be part of a generator expression
    # Hence pop contexts off stack if `for` keyword is matched in order to
    # not scope it invalid.
    - match: \bcr(?=\s|:|$)
      scope:
        meta.function.inline
        storage.type.function.inline
        keyword.declaration.function.inline
      push: [lambda-in-group-parameters, allow-unpack-operators]

  lambda-in-group-parameters:
    - meta_content_scope: meta.function.inline.parameters
    - match: ':'
      scope: punctuation.section.function.begin
      set:
        - meta_include_prototype: false
        - match: ''
          set: lambda-in-group-body
    - include: lambda-in-group-end
    - include: lambda-parameters-common

  lambda-in-group-body:
    - meta_scope: meta.function.inline.body
    - include: lambda-in-group-end
    - include: lambda-body

  lambda-in-group-end:
    - match: (?=for\b)
      pop: true

  lambda:
    - match: \bcr(?=\s|:|$)
      scope:
        meta.function.inline
        storage.type.function.inline
        keyword.declaration.function.inline
      push: [lambda-parameters, allow-unpack-operators]

  lambda-parameters:
    - meta_content_scope: meta.function.inline.parameters
    - match: ':'
      scope: punctuation.section.function.begin
      set:
        - meta_include_prototype: false
        - match: ''
          set: lambda-body
    - include: lambda-parameters-common

  lambda-parameters-common:
    - match: ','
      scope: punctuation.separator.parameters
      push: allow-unpack-operators
    - include: line-continuation-or-pop
    - include: keyword-arguments
    - include: function-parameters-tuple
    - include: illegal-names
    - match: '{{identifier}}'
      scope: variable.parameter
    - match: \S
      scope: invalid.illegal.expected-parameter

  lambda-body:
    - meta_scope: meta.function.inline.body
    - include: illegal-assignment-expression
    # We don't know whether we are within a grouped
    # or line-statement context at this point.
    # If we're in a group, the underlying context will take over
    # at the end of the line.
    - match: (?=[,:)}\]])|$
      pop: true
    - include: expression-in-a-statement

  generators-groups-and-tuples:
    - include: empty-tuples
    - match: (?=\()
      branch_point: generators-groups-and-tuples
      branch:
        - maybe-group
        - maybe-tuple
        - maybe-generator

  maybe-group:
    - match: \(
      scope: punctuation.section.group.begin
      set: inside-group

  inside-group:
    - meta_scope: meta.group
    - match: \)
      scope: punctuation.section.group.end
      set: after-expression
    - match: (?=,|\bfor\b)
      fail: generators-groups-and-tuples
    - include: expression-in-a-group

  maybe-generator:
    - match: \(
      scope: punctuation.section.sequence.begin
      set: inside-generator

  inside-generator:
    - meta_scope: meta.sequence.generator
    - match: \)
      scope: punctuation.section.sequence.end
      set: after-expression
    - include: inline-for
    - include: expression-in-a-group

  maybe-tuple:
    - match: \(
      scope: punctuation.section.sequence.begin
      set: inside-tuple

  inside-tuple:
    - meta_scope: meta.sequence.tuple
    - match: \)
      scope: punctuation.section.sequence.end
      set: after-expression
    - match: (?=\bfor\b)
      fail: generators-groups-and-tuples
    - include: sequence-separators
    - include: expression-in-a-group
    - match: '='
      scope: invalid.illegal.unexpected-assignment-in-tuple

  empty-tuples:
    - match: (\()\s*(\))
      scope: meta.sequence.tuple.empty
      captures:
        1: punctuation.section.sequence.begin
        2: punctuation.section.sequence.end
      push: after-expression

  lists:
    - include: empty-lists
    - match: \[
      scope: punctuation.section.sequence.begin
      push: [inside-list, allow-unpack-operators]

  inside-list:
    - meta_scope: meta.sequence.list
    - match: \]
      scope: punctuation.section.sequence.end
      set: after-expression
    - match: ','
      scope: punctuation.separator.sequence
      push: allow-unpack-operators
    - include: inline-for
    - include: expression-in-a-group

  empty-lists:
    - match: (\[)\s*(\])
      scope: meta.sequence.list.empty
      captures:
        1: punctuation.section.sequence.begin
        2: punctuation.section.sequence.end
      push: after-expression

  dictionaries-and-sets:
    - include: empty-dictionaries
    - match: (?=\{)
      branch_point: dictionaries-and-sets
      branch:
        - maybe-set
        - maybe-dictionary

  maybe-dictionary:
    - match: \{
      scope: punctuation.section.mapping.begin
      set: inside-dictionary

  inside-dictionary:
    - meta_scope: meta.mapping
    - match: \}
      scope: punctuation.section.mapping.end
      set: after-expression
    - include: illegal-assignment-expression
    - match: ':'
      scope: punctuation.separator.key-value
      set: inside-directory-value
    - match: ','
      scope: invalid.illegal.expected-colon
    - match: \*\*
      scope: keyword.operator.unpacking.mapping
      push:
        - match: (?=\})
          pop: true
        - match: ','
          scope: punctuation.separator.sequence
          pop: true
        - include: expression-in-a-group
    - include: comments
    - match: (?=\S)
      push:
        - clear_scopes: 1
        - meta_scope: meta.mapping.key
        - match: \s*(?=\}|,|:)
          pop: true
        - include: expression-in-a-group

  inside-directory-value:
    - meta_content_scope: meta.mapping
    - match: \}
      scope: punctuation.section.mapping.end
      set: after-expression
    - match: (?=,)
      set:
        # clear meta scope from this match, because 'inside-directory' has it in meta_scope
        - match: ','
          scope: punctuation.separator.sequence
          set: inside-dictionary
    - match: (?=(?:async|for)\b)
      push:
        - match: (?=\})
          pop: true
        - match: ','
          scope: invalid.illegal.unexpected-comma
        - include: inline-for
        - include: expression-in-a-group
    - include: comments
    - match: (?=\S)
      push:
        - clear_scopes: 1
        - meta_content_scope: meta.mapping.value
        - match: (?=\s*(\}|,|(?:async|for)\b))
          pop: true
        - include: expression-in-a-group

  maybe-set:
    - match: \{
      scope: punctuation.section.set.begin
      set: maybe-inside-set

  maybe-inside-set:
    - meta_scope: meta.set
    - match: (?=,|:=)
      set: inside-set
    - match: (?=:|\*\*)
      fail: dictionaries-and-sets
    - include: inside-set

  inside-set:
    - meta_scope: meta.set
    - match: \}
      scope: punctuation.section.set.end
      set: after-expression
    - match: ','
      scope: punctuation.separator.set
    - match: \*
      scope: keyword.operator.unpacking.sequence
      push:
        - match: (?=\})
          pop: true
        - match: (?=,)
          pop: true
        - include: expression-in-a-group
    - include: inline-for
    - include: expression-in-a-group
    - match: ':'
      scope: invalid.illegal.colon-inside-set

  empty-dictionaries:
    - match: (\{)\s*(\})
      scope: meta.mapping.empty
      captures:
        1: punctuation.section.mapping.begin
        2: punctuation.section.mapping.end
      push: after-expression

  illegal-stray-parens:
    - match: \)
      scope: invalid.illegal.stray

  illegal-stray-brackets:
    - match: \]
      scope: invalid.illegal.stray

  illegal-stray-braces:
    - match: \}
      scope: invalid.illegal.stray

  builtin-exceptions:
    - match: '{{builtin_exceptions}}'
      scope: support.type.exception

  builtin-functions:
    - match: '{{builtin_functions}}'
      scope: support.function.builtin

  builtin-types:
    - match: '{{builtin_types}}'
      scope: support.type

  name:
    - match: (?={{identifier}})
      push: name-content

  name-content:
    - include: name-specials
    - match: '{{identifier_constant}}'
      scope: variable.other.constant
    - include: generic-names
    - match: ''
      pop: true

  dotted-name:
    - match: \s*(\.)\s*(?={{identifier}})
      captures:
        1: punctuation.accessor.dot
      push: dotted-name-content

  dotted-name-content:
    - include: dotted-name-specials
    - match: '{{identifier_constant}}'
      scope: variable.other.constant
    - include: generic-names
    - match: ''
      pop: true

  qualified-name:
    - match: (?={{path}})
      push: qualified-name-content
    - match: \.
      scope: punctuation.accessor.dot

  qualified-name-content:
    - meta_scope: meta.qualified-name
    - include: name
    - include: dotted-name
    - match: ''
      pop: true

  qualified-name-until-leaf:
    # Push this together with another context to match a qualified name
    # until the last non-special identifier (if any).
    # This allows the leaf to be scoped individually.
    - meta_scope: meta.qualified-name
    # If a line continuation follows, this may or may not be the last leaf (most likley not though)
    - match: (?={{identifier}}\s*(\.|\\))
      push:
        - include: name-specials
        - include: generic-names
        - match: ''
          pop: true
    - match: (\.)\s*(?={{identifier}}\s*(\.|\\))
      captures:
        1: punctuation.accessor.dot
      push:
        - include: dotted-name-specials
        - include: generic-names
        - match: ''
          pop: true
    - match: \.(?!\s*{{identifier}})  # don't match last dot
      scope: punctuation.accessor.dot
    - match: (?=\S|$)
      pop: true

  name-specials:
    - include: builtin-functions
    - include: builtin-types
    - include: builtin-exceptions
    - include: illegal-names
    - include: magic-function-names
    - include: magic-variable-names
    - include: class-variables
    - include: wildcard-variables

  dotted-name-specials:
    - include: magic-function-names
    - include: magic-variable-names
    - include: illegal-names

  entity-name-class:
    - include: illegal-names
    - include: generic-names

  entity-name-function:
    - include: magic-function-names
    - include: illegal-names
    - include: generic-names

  generic-names:
    - match: '{{identifier}}'
      scope: meta.generic-name

  generic-name:
    - match: '{{identifier}}'
      scope: meta.generic-name
      pop: true

  illegal-names:
    - match: \b{{illegal_names}}\b
      scope: invalid.illegal.name

  illegal-name:
    - match: \b{{illegal_names}}\b
      scope: invalid.illegal.name
      pop: true

  class-variables:
    - match: \b(borg|cls)\b
      scope: variable.language

  wildcard-variables:
    - match: _(?!{{identifier_continue}})
      scope: variable.language.anonymous

  wildcard-variable:
    - match: _(?!{{identifier_continue}})
      scope: variable.language.anonymous
      pop: true

  line-continuation:
    - match: (\\)(.*)$\n?
      captures:
        1: punctuation.separator.continuation.line
        2: invalid.illegal.unexpected-text
    # make sure to resume parsing at next line
      push:
        # This prevents strings after a continuation from being a docstring
        - include: strings
        - match: (?=\S|^\s*$|\n)  # '\n' for when we matched a string earlier
          pop: true

  line-continuation-or-pop:
    - include: line-continuation
    - match: (?=\s*($|;|#))
      pop: true

  else-pop:
    - match: (?=\S)
      pop: true

  magic-function-names:
    # https://docs.org/2/reference/datamodel.html
    # https://docs.org/3/reference/datamodel.html
    - match: |-
        (?x)\b__(?:
          # unary operators
          invert|neg|pos|abs|
          # binary operators
          add|and|div|divmod|floordiv|lshift|mod|mul|or|pow|rshift|sub|truediv|xor|
          contains|
          # right-hand binary operators
          radd|rand|rdiv|rdivmod|rfloordiv|rlshift|rmod|rmul|ror|rpow|rrshift|rsub|rtruediv|rxor|
          # in-place operator assignments
          iadd|iand|idiv|ifloordiv|ilshift|imod|imul|ior|ipow|irshift|isub|itruediv|ixor|
          # comparisons
          eq|ge|gt|le|lt|ne|
          cmp|rcmp| # py2
          # primary coercion
          bool|str|
          nonzero|unicode| # py2
          # number coercion (converts something to a number)
          bytes|complex|float|index|int|round|
          long| # py2
          # other "coercion"
          format|len|length_hint|hash|repr|reversed|
          coerce|hex|oct| # py2
          fspath|
          # iterator (and 'await')
          iter|next|
          aiter|anext|
          await|
          # attribute and item access
          delattr|delitem|delslice|
          getattr|getattribute|getitem|getslice|
          setattr|setitem|setslice|
          dir|missing|
          # context manager
          enter|exit|
          aenter|aexit|
          # other class magic
          call|del|init|new|init_subclass|
          instancecheck|subclasscheck|
          # pickling
          getnewargs|getnewargs_ex|getstate|setstate|reduce|reduce_ex|
          # descriptors
          delete|get|set|set_name|
          # class-specific
          subclasses|
          # dataclasses (PEP 557)
          post_init|
          # for typing core support (PEP 560)
          class_getitem|mro_entries
        )__\b
      comment: these methods have magic interpretation by python and are generally called indirectly through syntactic constructs
      scope: support.function.magic

  magic-variable-names:
    # magic variables which a class/module/object may have.
    # https://docs.org/3/library/inspect.html#types-and-members
    # https://docs.org/3/reference/datamodel.html#object.__slots__
    # https://docs.org/3/reference/datamodel.html#preparing-the-class-namespace
    - match: |-
        (?x)\b__(?:
          # generic object
          class|dict|doc|module|name|
          # module-specific / global
          all|file|package|
          # functions & methods
          annotations|closure|code|defaults|func|globals|kwdefaults|self|qualname|
          # classes (attributes)
          bases|prepare|slots|metaclass|mro|
          # Python 2
          members|methods
        )__\b
      scope: support.variable.magic

  docstrings:
    - match: ^\s*(?=(?i)(ur|ru|u|r)?("""|'''))
      push:
      - match: (?i)(u)?("""|''')
        captures:
          1: storage.type.string
          2: punctuation.definition.comment.begin
        set:
          - meta_scope: comment.block.documentation
          - include: escaped-unicode-char
          - include: escaped-char
          - match: '\2'
            scope: punctuation.definition.comment.end
            pop: true
      - match: (?i)(u?ru?)("""|''')
        captures:
          1: storage.type.string
          2: punctuation.definition.comment.begin
        set:
          - meta_scope: comment.block.documentation
          - match: '\2'
            scope: punctuation.definition.comment.end
            pop: true

  escaped-char:
    - match: '(\\x\h{2})|(\\[0-7]{1,3})|(\\[\\"''abfnrtv])'
      captures:
        1: constant.character.escape.hex
        2: constant.character.escape.octal
        3: constant.character.escape
    - match: \\.  # deprecated in 3.6 and will eventually be a syntax error
      scope: invalid.deprecated.character.escape

  escaped-unicode-char:
    - match: '(\\U\h{8})|(\\u\h{4})|(\\N\{[-a-zA-Z ]+\})'
      captures:
        1: constant.character.escape.unicode.16-bit-hex
        2: constant.character.escape.unicode.32-bit-hex
        3: constant.character.escape.unicode.name

  escaped-fstring-escape:
    # special-case the '\{{' sequence because it has higher priority than the deprecated '\{'
    - match: (\\)(\{\{|\}\})
      scope: constant.character.escape.backslash.regexp
      captures:
        1: invalid.deprecated.character.escape
        2: constant.character.escape

  line-continuation-inside-string:
    - match: (\\)$\n?
      captures:
        1: punctuation.separator.continuation.line
    - match: \n
      scope: invalid.illegal.unclosed-string
      set: after-expression

  line-continuation-inside-block-string:
    - match: \\$
      scope: punctuation.separator.continuation.line

  constant-placeholder:
    - match: |- # printf style
        (?x)
        %
          ( \( ({{identifier}}) \) )? # mapping key
          \#?            # alternate form
          0?             # pad with zeros
          \-?            # left-adjust
          \ ?            # implicit sign
          [+-]?          # sign
          (\d*|\*)       # width
          (\. (\d*|\*))? # precision
          [hlL]?         # length modifier (but ignored)
          [acdeEfFgGiorsuxX%]
      scope: constant.other.placeholder
      captures:
        2: variable.other.placeholder
    - match: '{{strftime_spec}}'
      scope: constant.other.placeholder
    - match: '\{\{|\}\}'
      scope: constant.character.escape
    - include: formatting-syntax

  formatting-syntax:
    # https://docs.org/3.6/library/string.html#formatstrings
    # Technically allows almost every character for the key,
    # but those are rarely used if ever.
    - match: |- # simple form
        (?x)
        (\{)
          (?: [\w.\[\]]+)?           # field_name
          (   ! [ars])?              # conversion
          (?: (:) ({{format_spec}}|  # format_spec OR
                   [^}%]*%.[^}]*)    # any format-like string
          )?
        (\})
      scope: constant.other.placeholder
      captures:
        1: punctuation.definition.placeholder.begin
        2: storage.modifier.conversion
        3: punctuation.separator.format-spec
        4: meta.format-spec constant.other.format-spec
        5: punctuation.definition.placeholder.end
    - match: (?=\{[^{}"']+\{[^"']*\})  # complex (nested) form
      branch_point: formatting-syntax-branch
      branch:
        - formatting-syntax-complex
        - formatting-syntax-fallback

  formatting-syntax-fallback:
    - match: \{
      scope: meta.debug.formatting-syntax-fallback
      pop: true

  formatting-syntax-complex:
    - match: \{
      scope: punctuation.definition.placeholder.begin
      set:
        - meta_scope: constant.other.placeholder
        - match: \}
          scope: punctuation.definition.placeholder.end
          pop: true
        # TODO could match numeric indices or everything else as a key
        # and also [] indexing
        - match: '![ars]'
          scope: storage.modifier.conversion
        - match: ':'
          scope: punctuation.separator.format-spec
          push:
            - meta_content_scope: meta.format-spec constant.other.format-spec
            - match: (?=\})
              pop: true
            - match: (?=\{)
              push: formatting-syntax-complex
        - match: '[{"''\n]'
          fail: formatting-syntax-branch

  f-string-content:
    # https://www.org/dev/peps/pep-0498/
    # https://docs.org/3.6/reference/lexical_analysis.html#f-strings
    - match: \{\{|\}\}
      scope: constant.character.escape
    - match: \{\s*\}
      scope: invalid.illegal.empty-expression
    - include: f-string-replacements
    - include: illegal-stray-braces

  f-string-content-with-regex:
    # Same as f-string-content, but will reset the entire scope stack
    # and has an additional match.
    - match: \\(\{\{|\}\})
      scope: constant.character.escape.backslash.regexp
      captures:
        1: constant.character.escape
    - match: \{\{|\}\}
      scope: constant.character.escape
    - match: \{\s*\}
      scope: invalid.illegal.empty-expression
    - include: f-string-replacements-reset
    - include: illegal-stray-braces

  f-string-replacements:
    - match: \{
      scope: punctuation.section.interpolation.begin
      push:
        - f-string-replacement-meta
        - f-string-replacement-modifier
        - f-string-replacement-expression

  f-string-replacement-meta:
    - clear_scopes: 1
    - meta_include_prototype: false
    - meta_scope: meta.interpolation
    - match: ''
      pop: 1

  f-string-replacement-expression:
    - meta_content_scope: source.embedded
    - match: (?=\s*(?:=\s*)?(![^=]|:|\}))
      pop: 1
    - match: \\
      scope: invalid.illegal.backslash-in-fstring
    - include: inline-for
    - include: expression-in-a-group

  f-string-replacement-modifier:
    - include: f-string-replacement-end
    - include: f-string-replacement-common
    - match: =
      scope: storage.modifier.debug

  f-string-replacements-reset:
    - match: \{
      scope: punctuation.section.interpolation.begin
      push:
        - f-string-replacement-reset-meta
        - f-string-replacement-reset-modifier
        - f-string-replacement-reset-expression

  f-string-replacement-reset-meta:
    # Same as f-string-replacement, but with clear_scopes: true
    - clear_scopes: true
    - meta_include_prototype: false
    - meta_scope: source meta.string.interpolated meta.interpolation
    - match: ''
      pop: 1

  f-string-replacement-reset-expression:
    - meta_content_scope: source.embedded
    - match: (?=![^=]|:|\})
      pop: 1
    - match: \\
      scope: invalid.illegal.backslash-in-fstring
    - include: inline-for
    - include: expression-in-a-group

  f-string-replacement-reset-modifier:
    - include: f-string-replacement-end
    - include: f-string-replacement-common

  f-string-replacement-common:
    - match: '![ars]'
      scope: storage.modifier.conversion
    - match: ':'
      scope: meta.format-spec constant.other.format-spec punctuation.separator.format-spec
      set: f-string-format-spec

  f-string-format-spec:
    - meta_content_scope: meta.format-spec constant.other.format-spec
    # Because replacements can also be used *within* the format-spec,
    # basically any character is valid and matching {{format_spec}} is useless.
    # - match: '{{format_spec}}'
    - include: f-string-replacement-end
    - include: f-string-content

  f-string-replacement-end:
    - match: \}
      scope: punctuation.section.interpolation.end
      pop: 2

  string-quoted-double-block:
    # Triple-quoted capital R raw string, unicode or not, no syntax embedding
    - match: '([uU]?R)(""")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double.block
        - match: '"""'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: escaped-unicode-char
    # Triple-quoted capital R raw string, bytes, no syntax embedding
    - match: '([bB]R|R[bB])(""")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double.block
        - match: '"""'
          scope: punctuation.definition.string.end
          set: after-expression
    # Triple-quoted raw string, unicode or not, will detect SQL, otherwise regex
    - match: '([uU]?r)(""")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double.block
        - match: '(?={{sql_indicator}})'
          set:
            - meta_scope: meta.string
            - match: '"""'
              scope: string.quoted.double.block punctuation.definition.string.end
              set: after-expression
            - match: ''
              push: scope:source.sql
              with_prototype:
                - match: '(?=""")'
                  pop: true
                - include: escaped-unicode-char
                - include: constant-placeholder
        - match: '(?=\S)'
          set:
            - meta_scope: meta.string string.quoted.double.block
            - match: '"""'
              scope: punctuation.definition.string.end
              set: after-expression
            - match: ''
              push: scope:source.regexp
              with_prototype:
                - match: '(?=""")'
                  pop: true
                - include: escaped-unicode-char
    # Triple-quoted raw string, bytes, will use regex
    - match: '([bB]r|r[bB])(""")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double.block
        - match: '"""'
          scope: punctuation.definition.string.end
          set: after-expression
        - match: ''
          embed: scope:source.regexp
          escape: (?=""")
    # Triple-quoted raw f-string
    - match: ([fF]R|R[fF])(""")
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.double.block
        - match: '"""'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: f-string-content
    # Triple-quoted raw f-string, treated as regex
    - match: ([fF]r|r[fF])(""")
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.double.block
        - match: '"""'
          scope: punctuation.definition.string.end
          set: after-expression
        - match: ''
          push: scope:source.regexp
          with_prototype:
            - match: '(?=""")'
              pop: true
            - include: f-string-content-with-regex
    # Triple-quoted f-string
    - match: ([fF])(""")
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.double.block
        - match: '"""'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-block-string
        - include: escaped-fstring-escape
        - include: escaped-unicode-char
        - include: escaped-char
        - include: f-string-content
    # Triple-quoted string, unicode or not, will detect SQL
    - match: '([uU]?)(""")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double.block
        - match: '(?={{sql_indicator}})'
          set:
            - meta_scope: meta.string
            - match: '"""'
              scope: string.quoted.double.block punctuation.definition.string.end
              set: after-expression
            - match: ''
              push: scope:source.sql
              with_prototype:
                - match: '(?=""")'
                  pop: true
                - include: line-continuation-inside-block-string
                - include: escaped-unicode-char
                - include: escaped-char
                - include: constant-placeholder
        - match: '(?=\S)'
          set:
            - meta_scope: meta.string string.quoted.double.block
            - match: '"""'
              scope: punctuation.definition.string.end
              set: after-expression
            - include: line-continuation-inside-block-string
            - include: escaped-unicode-char
            - include: escaped-char
            - include: constant-placeholder
    # Triple-quoted string, bytes, no syntax embedding
    - match: '([bB])(""")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double.block
        - match: '"""'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-block-string
        - include: escaped-char
        - include: constant-placeholder

  string-quoted-double:
    # Single-line capital R raw string, unicode or not, no syntax embedding
    - match: '([uU]?R)(")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
    # Single-line capital R raw string, bytes, no syntax embedding
    - match: '([bB]R|R[bB])(")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
    # Single-line raw string, unicode or not, starting with a SQL keyword
    - match: '([uU]?r)(")(?={{sql_indicator}})'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string
        - match: '"'
          scope: string.quoted.double punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.sql
          with_prototype:
            - match: '(?="|\n)'
              pop: true
            - include: constant-placeholder
            - include: line-continuation-inside-string
    # Single-line raw string, unicode or not, treated as regex
    - match: '([uU]?r)(")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.regexp
          with_prototype:
            - match: '(?="|\n)'
              pop: true
            - include: line-continuation-inside-string
    # Single-line raw string, bytes, treated as regex
    - match: '([bB]r|r[bB])(")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          embed: scope:source.regexp
          escape: (?="|\n)
    # Single-line raw f-string
    - match: (R[fF]|[fF]R)(")
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - include: f-string-content
    # Single-line raw f-string, treated as regex
    - match: (r[fF]|[fF]r)(")
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.regexp
          with_prototype:
            - match: '(?="|\n)'
              pop: true
            - include: line-continuation-inside-string
            - include: f-string-content-with-regex
    # Single-line f-string
    - match: ([fF])(")
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: escaped-fstring-escape
        - include: escaped-unicode-char
        - include: escaped-char
        - include: line-continuation-inside-string
        - include: f-string-content
    # Single-line string, unicode or not, starting with a SQL keyword
    - match: '([uU]?)(")(?={{sql_indicator}})'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string
        - match: '"'
          scope: string.quoted.double punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.sql
          with_prototype:
            - match: '(?="|\n)'
              pop: true
            - include: escaped-unicode-char
            - include: escaped-char
            - include: line-continuation-inside-string
            - include: constant-placeholder
    # Single-line string, unicode or not
    - match: '([uU]?)(")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: escaped-unicode-char
        - include: escaped-char
        - include: line-continuation-inside-string
        - include: constant-placeholder
    # Single-line string, bytes
    - match: '([bB])(")'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.double punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.double
        - match: '"'
          scope: punctuation.definition.string.end
          set: after-expression
        - include: escaped-char
        - include: line-continuation-inside-string
        - include: constant-placeholder

  string-quoted-single-block:
    # Triple-quoted capital R raw string, unicode or not, no syntax embedding
    - match: ([uU]?R)(''')
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single.block
        - match: "'''"
          scope: punctuation.definition.string.end
          set: after-expression
    # Triple-quoted capital R raw string, bytes, no syntax embedding
    - match: ([bB]R|R[bB])(''')
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single.block
        - match: "'''"
          scope: punctuation.definition.string.end
          set: after-expression
    # Triple-quoted raw string, unicode or not, will detect SQL, otherwise regex
    - match: ([uU]?r)(''')
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single.block
        - match: '(?={{sql_indicator}})'
          set:
            - meta_scope: meta.string
            - match: "'''"
              scope: string.quoted.single.block punctuation.definition.string.end
              set: after-expression
            - match: ''
              push: scope:source.sql
              with_prototype:
                - match: (?=''')
                  pop: true
                - include: escaped-unicode-char
                - include: escaped-char
                - include: constant-placeholder
        - match: '(?=\S)'
          set:
            - meta_scope: meta.string string.quoted.single.block
            - match: "'''"
              scope: punctuation.definition.string.end
              set: after-expression
            - match: ''
              push: scope:source.regexp
              with_prototype:
                - match: (?=''')
                  pop: true
                - include: escaped-unicode-char
    # Triple-quoted raw string, bytes, will use regex
    - match: ([bB]r|r[bB])(''')
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single.block
        - match: "'''"
          scope: punctuation.definition.string.end
          set: after-expression
        - match: ''
          embed: scope:source.regexp
          escape: (?=''')
    # Triple-quoted raw f-string
    - match: ([fF]R|R[fF])(''')
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.single.block
        - match: "'''"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: f-string-content
    # Triple-quoted raw f-string, treated as regex
    - match: ([fF]r|r[fF])(''')
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.single.block
        - match: "'''"
          scope: punctuation.definition.string.end
          set: after-expression
        - match: ''
          push: scope:source.regexp
          with_prototype:
            - match: (?=''')
              pop: true
            - include: f-string-content-with-regex
    # Triple-quoted f-string
    - match: ([fF])(''')
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.single.block
        - match: "'''"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-block-string
        - include: escaped-fstring-escape
        - include: escaped-unicode-char
        - include: escaped-char
        - include: f-string-content
    # Triple-quoted string, unicode or not, will detect SQL
    - match: ([uU]?)(''')
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single.block
        - match: '(?={{sql_indicator}})'
          set:
            - meta_scope: meta.string
            - match: "'''"
              scope: string.quoted.single.block punctuation.definition.string.end
              set: after-expression
            - match: ''
              push: scope:source.sql
              with_prototype:
                - match: (?=''')
                  pop: true
                - include: line-continuation-inside-block-string
                - include: escaped-unicode-char
                - include: escaped-char
                - include: constant-placeholder
        - match: '(?=\S)'
          set:
            - meta_scope: meta.string string.quoted.single.block
            - match: "'''"
              scope: punctuation.definition.string.end
              set: after-expression
            - include: line-continuation-inside-block-string
            - include: escaped-unicode-char
            - include: escaped-char
            - include: constant-placeholder
    # Triple-quoted string, bytes, no syntax embedding
    - match: ([bB])(''')
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single.block punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single.block
        - match: "'''"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-block-string
        - include: escaped-char
        - include: constant-placeholder

  string-quoted-single:
    # Single-line capital R raw string, unicode or not, no syntax embedding
    - match: '([uU]?R)('')'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
    # Single-line capital R raw string, bytes, no syntax embedding
    - match: '([bB]R|R[bB])('')'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
    # Single-line raw string, unicode or not, starting with a SQL keyword
    - match: '([uU]?r)('')(?={{sql_indicator}})'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string
        - match: "'"
          scope: string.quoted.single punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.sql
          with_prototype:
            - match: '(?=''|\n)'
              pop: true
            - include: line-continuation-inside-string
            - include: constant-placeholder
    # Single-line raw string, unicode or not, treated as regex
    - match: '([uU]?r)('')'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.regexp
          with_prototype:
            - match: '(?=''|\n)'
              pop: true
            - include: line-continuation-inside-string
    # Single-line raw string, bytes, treated as regex
    - match: '([bB]r|r[bB])('')'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.regexp
          with_prototype:
            - match: '(?=''|\n)'
              pop: true
            - include: line-continuation-inside-string
    # Single-line raw f-string
    - match: ([fF]R|R[fF])(')
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - include: f-string-content
    # Single-line raw f-string, treated as regex
    - match: ([fF]r|r[fF])(')
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.regexp
          with_prototype:
            - match: (?='|\n)
              pop: true
            - include: line-continuation-inside-string
            - include: f-string-content-with-regex
    # Single-line f-string
    - match: ([fF])(')
      captures:
        1: storage.type.string
        2: meta.string.interpolated string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string.interpolated string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: escaped-fstring-escape
        - include: escaped-unicode-char
        - include: escaped-char
        - include: line-continuation-inside-string
        - include: f-string-content
    # Single-line string, unicode or not, starting with a SQL keyword
    - match: '([uU]?)('')(?={{sql_indicator}})'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string
        - match: "'"
          scope: string.quoted.single punctuation.definition.string.end
          set: after-expression
        - include: line-continuation-inside-string
        - match: ''
          push: scope:source.sql
          with_prototype:
            - match: '(?=''|\n)'
              pop: true
            - include: escaped-unicode-char
            - include: escaped-char
            - include: line-continuation-inside-string
            - include: constant-placeholder
    # Single-line string, unicode or not
    - match: '([uU]?)('')'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: escaped-unicode-char
        - include: escaped-char
        - include: line-continuation-inside-string
        - include: constant-placeholder
    # Single-line string, bytes
    - match: '([bB])('')'
      captures:
        1: storage.type.string
        2: meta.string string.quoted.single punctuation.definition.string.begin
      push:
        - meta_content_scope: meta.string string.quoted.single
        - match: "'"
          scope: punctuation.definition.string.end
          set: after-expression
        - include: escaped-char
        - include: line-continuation-inside-string
        - include: constant-placeholder

  strings:
    # block versions must be matched first
    - include: string-quoted-double-block
    - include: string-quoted-double
    - include: string-quoted-single-block
    - include: string-quoted-single

  inline-for:
    - match: \b(?:(async)\s+)?(for)\b
      captures:
        1: storage.modifier.async
        2: keyword.control.loop.for.generator
      push: inside-inline-for

  inside-inline-for:
    - meta_scope: meta.expression.generator
    - match: \bin\b
      scope: keyword.control.loop.for.in
      pop: true
    - match: (?=[)\]}])
      pop: true
    - include: comments
    - include: illegal-name
    - include: target-lists

  inline-if:
    - match: \bwhether\b
      scope: keyword.control.conditional.if
    - match: \botherwise\b
      scope: keyword.control.conditional.else

  target-lists:
    - match: \(
      scope: punctuation.section.tuple.begin
      push: inside-target-list
    - match: ','
      scope: punctuation.separator.sequence
    - include: name

  inside-target-list:
    - meta_scope: meta.sequence.tuple
    - match: \)
      scope: punctuation.section.tuple.end
      pop: true
    - include: comments
    - include: target-lists
